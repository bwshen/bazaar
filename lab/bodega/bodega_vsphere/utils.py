"""Utility functions for Bodega VSphere."""
import logging
import random
from datetime import datetime, timedelta
from time import sleep

from bodega_core.exceptions import bodega_error, bodega_value_error
from bodega_core.models import Item
from bodega_vsphere.models import EsxHost, VSphereFarm
from memoize import memoize
from pytz import utc
from pyVim.connect import Disconnect, SmartConnectNoSSL
from pyVmomi import vim, vmodl

log = logging.getLogger(__name__)


def _wait_for_task(task, virtual_machine, timeout=timedelta(seconds=1200)):
    """Wait for the vCenter task to complete."""
    log.info("Waiting for task %s to complete for VM %s"
             % (task.info.descriptionId, virtual_machine))

    start_time = datetime.now(utc)
    while datetime.now(utc) - start_time < timeout:
        if task.info.state == vim.TaskInfo.State.success:
            log.debug('Task succeeded')
            break

        if task.info.state == vim.TaskInfo.State.error:
            bodega_error(log, 'Failed task %s' % (task.info))

        log.debug('Waiting for task %s for %s to complete'
                  % (task.info.descriptionId, virtual_machine))
        sleep(15)
    if task.info.state != vim.TaskInfo.State.success:
        bodega_error(log,
                     "Task %s for %s did not succeed after %d sec"
                     % (task.info.descriptionId, virtual_machine,
                        timeout.total_seconds()))
    else:
        log.info("Task completed with status %s" % task.info.state)
    return task.info.state


def _get_object_by_name(vcenter_session, vimtype, name):
    """Return an object of vimtype by name."""
    content = vcenter_session.RetrieveContent()
    container = content.viewManager.CreateContainerView(
        content.rootFolder, vimtype, recursive=True)
    for view_object in container.view:
        if view_object.name == name:
            return view_object
    return None


def _get_vcenter_session(virtual_machine):
    session = SmartConnectNoSSL(host=virtual_machine.vcenter.url,
                                user=virtual_machine.vcenter.username,
                                pwd=virtual_machine.vcenter.password,
                                port=443)
    return session


def _get_vsphere_vm_by_moid(moid, vcenter_session):
    """Get the vSphere (pyVmomi) VM by MOID.

    pyVmomi doesn't expose any methods officially to get a VM by its MOID so
    we need to manually create a vim.VirtualMachine object with the moid and
    session. If the object with the MOID does not exist, then doing an
    operation such as `vm.name` will generate a ManagedObjectNotFound error.
    """
    log.debug('Searching for VM with moid of %s' % moid)
    vm = vim.VirtualMachine(moid)
    vm._stub = vcenter_session._stub
    try:
        vm.name
        return vm
    except vmodl.fault.ManagedObjectNotFound:
        log.warning('Caught ManagedObjectNotFound warning while searching '
                    'for the VM with moid %s' % moid)
        return None


def _get_vsphere_vm_by_instance_uuid(instance_uuid, vcenter_session):
    log.debug('Searching for VM with instanceUuid of %s' % instance_uuid)
    vm = vcenter_session.content.searchIndex.FindByUuid(datacenter=None,
                                                        uuid=instance_uuid,
                                                        vmSearch=True,
                                                        instanceUuid=True)
    return vm


def _get_vsphere_vm_by_name(name, vcenter_session):
    log.debug('Searching for VM with name of %s' % name)
    vm = _get_object_by_name(vcenter_session, [vim.VirtualMachine], name)
    return vm


def _get_vsphere_vm(virtual_machine, vcenter_session):
    """Get the pyVmomi representation of the virtual machine.

    We will try several methods to try and get the  pyVmomi representation
    of the VirtualMachine starting with the most correct methods and falling
    back to less accurate methods if need be.

    1. The MOID is the standard primary key across all VMware products and is
    unique within a vCenter.

    2. The instanceUuid is guaranteed to be unique within a vCenter but is more
    stable for VMs moving between vCenters.

    3. The name of a VM is unique enough in practice because we use SIDs
    generated by Bodega. However, the SIDs are not guaranteed unique between
    all instances of Bodega and a user could also introduce a conflicting name.
    """
    if virtual_machine.moid:
        vsphere_vm = _get_vsphere_vm_by_moid(
            virtual_machine.moid,
            vcenter_session)
    elif virtual_machine.instance_uuid:
        vsphere_vm = _get_vsphere_vm_by_instance_uuid(
            virtual_machine.instance_uuid,
            vcenter_session)
    elif virtual_machine._name:
        vsphere_vm = _get_vsphere_vm_by_name(virtual_machine._name,
                                             vcenter_session)
    else:
        bodega_error(log, 'VirtualMachine %s does not have a _name or an '
                          'associated instance_uuid.' % virtual_machine)

    if vsphere_vm:
        log.info('Found matching VM %s for %s' % (vsphere_vm, virtual_machine))
    else:
        log.warning('Could not find matching VM for %s' % virtual_machine)
    return vsphere_vm


def _get_destination_folder(vcenter_session):
    # For now we are just using the default folder but this may change
    # in the future if we need to be more organized with where we place
    # our created VMs.
    dc = vcenter_session.content.rootFolder.childEntity[0]
    destination_folder = dc.vmFolder
    return destination_folder


def _get_datastore_for_esx_host(esx_host, vcenter_session):
    """Get the datastore for the virtual machine.

    For now, we'll just pick the first datastore which is associated to the
    chosen EsxHost which should be the local ssd.
    """
    vsphere_esx_host = _get_object_by_name(vcenter_session,
                                           [vim.HostSystem],
                                           esx_host.url)
    datastore = vsphere_esx_host.datastore[0]
    return datastore


def _get_resource_pool_for_esx_host(esx_host, vcenter_session):
    vsphere_esx_host = _get_object_by_name(vcenter_session,
                                           [vim.HostSystem],
                                           esx_host.url)
    resource_pool = vsphere_esx_host.parent.resourcePool
    return resource_pool


def _wait_for_virtual_machine_to_be_ready(virtual_machine,
                                          vcenter_session,
                                          polling_interval=10,
                                          max_tries=60):
    """Wait for the virtual machine to be operational.

    For a virtual machine to be considered ready, we want it to be
    powered on and reporting an ip address and guest OS.
    """
    vsphere_vm = _get_vsphere_vm(virtual_machine, vcenter_session)
    num_tries = 0
    while True:
        powered_on = \
            vsphere_vm.runtime.powerState == vim.VirtualMachinePowerState.poweredOn
        ip_address = vsphere_vm.guest.ipAddress

        guest_os = \
            vsphere_vm.guest.guestFullName if vsphere_vm.guest else None
        guest_os_id = \
            vsphere_vm.guest.guestId if vsphere_vm.guest else None
        log.debug("VM %s has powered_on=%s, ip_address=%s, guest_id=%s, "
                  "guest_os=%s" %
                  (virtual_machine, repr(powered_on), repr(ip_address),
                   repr(guest_os_id), repr(guest_os)))
        if powered_on and guest_os and ip_address:
            log.debug("VM %s is Powered-On and operational"
                      % (virtual_machine))
            break

        if num_tries > max_tries:
            bodega_error("VM %s is not ready for operations after %s seconds."
                         % (virtual_machine, max_tries * polling_interval))
        log.debug('Attempt %d of %d: Sleeping for %d seconds before '
                  're-checking readiness of %s.'
                  % (num_tries + 1, max_tries, polling_interval,
                     virtual_machine))
        sleep(polling_interval)
        num_tries = num_tries + 1


def get_esx_host(location, esx_hardware):
    """Get an EsxHost which satisfies the location and version.

    TODO(INFRA-3637): Move away from this naive approach
    """
    log.debug('Selecting esx host with location of %s and hardware of %s'
              % (location, esx_hardware))
    vsphere_farm = VSphereFarm.objects.get(location=location)
    vcenter = random.choice(vsphere_farm.vcenters.all())
    esx_host = random.choice(vcenter.esx_hosts.filter(hardware=esx_hardware))
    return esx_host


def get_hardware_and_size_for_model(model):
    """Get the hardware and size for the given model.

    Given a model of vsphere-compute1.small, the hardware will be equal
    to "compute" and the size will be "small"
    """
    for (hardware, description) in EsxHost.ESXI_HARDWARE_CHOICES:
        if hardware.lower() in model.lower():
            log.info('"%s" found in model which is the hardware for %s.'
                     % (hardware, model))
            size = model.split('.')[1]
            return hardware, size
    bodega_value_error(log, 'Could not determine requested hardware for %s'
                            % model)


@memoize(timeout=timedelta(minutes=15).total_seconds())
def get_virtual_machine_ipv4_address(virtual_machine):
    vcenter_session = _get_vcenter_session(virtual_machine)
    try:
        vsphere_vm = _get_vsphere_vm(virtual_machine, vcenter_session)
        ipv4_address = vsphere_vm.guest.ipAddress
        if not ipv4_address:
            bodega_error(log,
                         'Could not determine ip address for %s'
                         % virtual_machine)
    finally:
        Disconnect(vcenter_session)
    return ipv4_address


def power_off_virtual_machine(virtual_machine):
    vcenter_session = _get_vcenter_session(virtual_machine)
    try:
        vsphere_vm = _get_vsphere_vm(virtual_machine, vcenter_session)
        if vsphere_vm.runtime.powerState == \
                vim.VirtualMachinePowerState.poweredOn:
            task = vsphere_vm.PowerOffVM_Task()
            _wait_for_task(task, virtual_machine)
        else:
            log.info('VM %s has power state %s and cannot be powered off.'
                     % (vsphere_vm, vsphere_vm.runtime.powerState))
    finally:
        Disconnect(vcenter_session)


def delete_virtual_machine(virtual_machine):
    vcenter_session = _get_vcenter_session(virtual_machine)
    try:
        vsphere_vm = _get_vsphere_vm(virtual_machine, vcenter_session)
        if not vsphere_vm:
            log.warning('Could not find %s' % virtual_machine)
        else:
            if vsphere_vm.runtime.powerState == \
                    vim.VirtualMachinePowerState.poweredOn:
                power_off_virtual_machine(virtual_machine)
            task = vsphere_vm.Destroy_Task()
            _wait_for_task(task, virtual_machine)
    finally:
        Disconnect(vcenter_session)
    virtual_machine.state = Item.STATE_DESTROYED
    virtual_machine.save()


def create_virtual_machine_on_vsphere(virtual_machine,
                                      esx_host,
                                      template_name,
                                      datastore_name=None,
                                      cpu_count=None,
                                      ram_size_GB=None):
    """Create the VirtualMachine on the EsxHost given the template name."""
    vcenter_session = _get_vcenter_session(virtual_machine)
    try:
        resource_pool = _get_resource_pool_for_esx_host(esx_host,
                                                        vcenter_session)
        template = _get_object_by_name(vcenter_session,
                                       [vim.VirtualMachine],
                                       template_name)
        if not datastore_name:
            log.info('No datastore specified so fetching logical datastore '
                     'for host %s' % esx_host)
            datastore = _get_datastore_for_esx_host(esx_host, vcenter_session)
        else:
            log.info('Using datastore %s for this VirtualMachine.'
                     % datastore_name)
            datastore = _get_object_by_name(vcenter_session,
                                            [vim.Datastore],
                                            datastore_name)

        relocate_spec = vim.vm.RelocateSpec(datastore=datastore,
                                            pool=resource_pool)
        config_spec = vim.vm.ConfigSpec()
        if cpu_count:
            config_spec.numCPUs = cpu_count
        if ram_size_GB:
            config_spec.memoryMB = int(ram_size_GB * 1024)
        clone_spec = vim.vm.CloneSpec(location=relocate_spec,
                                      config=config_spec,
                                      powerOn=True)
        destination_folder = _get_destination_folder(vcenter_session)

        task = template.Clone(folder=destination_folder,
                              name=virtual_machine._name,
                              spec=clone_spec)
        _wait_for_task(task, virtual_machine)

        vsphere_vm = _get_vsphere_vm(virtual_machine, vcenter_session)
        virtual_machine.instance_uuid = vsphere_vm.config.instanceUuid
        virtual_machine.moid = vsphere_vm._moId
        virtual_machine.save()

        _wait_for_virtual_machine_to_be_ready(virtual_machine, vcenter_session)
    finally:
        Disconnect(vcenter_session)
